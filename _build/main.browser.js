;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
(function($) {

  var editorconfig = require('./node_modules/editorconfig/editorconfig.js');

  function createFiles() {
    return [{
      name: $.get('.editorconfig input').value,
      contents: $.get('.editorconfig textarea').value
    }];
  }

  var setTextAreaHeight = function (el) {
    // Set textarea height
    el.style.height = 'auto';
    el.style.height = el.scrollHeight + 16 + 'px';

    // Get maximum section height
    var maxHeight = 0;
    $.byTag('section').forEach(function(el) {
      el.style.height = 'auto';
      if (el.clientHeight > maxHeight) maxHeight = el.clientHeight;
    });

    // Set section height
    $.byTag('section').forEach(function(el) { el.style.height = maxHeight; });
  };

  $.byTag('textarea').forEach(function(el) {
    var textareaInput = function () { setTextAreaHeight(el); };
    el.on('input', textareaInput);
    textareaInput();
  });

  $('input, textarea').forEach(function (el) {
    var updateDemo = function () {
      var configFiles = createFiles();
      $('.output [name=filename]').forEach(function (el) {
        var output = "";
        var config = editorconfig.parseFromFiles(el.value, configFiles);
        for (var key in config) {
          output += key + " = " + config[key] + "\n";
        }
        $.get('.output pre').innerText = output;
      });
    };
    el.on('input', updateDemo);
    updateDemo();
  });

}(vQuery));

},{"./node_modules/editorconfig/editorconfig.js":2}],3:[function(require,module,exports){
// nothing to see here... no file methods for the browser

},{}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],5:[function(require,module,exports){
(function(process){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

})(require("__browserify_process"))
},{"__browserify_process":4}],2:[function(require,module,exports){
var fs = require('fs');
var path = require('path');

var minimatch = require('./lib/fnmatch');
var iniparser = require('./lib/ini');
var Version = require('./lib/version');
var pkg = require('./package.json');


var knownProps = ['end_of_line', 'indent_style', 'indent_size',
    'insert_final_newline', 'trim_trailing_whitespace', 'charset'];


function fnmatch(filepath, glob) {
  var matchOptions = {matchBase: true, dot: true, noext: true};
  glob = glob.replace(/\*\*/g, '{*,**/**/**}');
  return minimatch(filepath, glob, matchOptions);
}


function getConfigFileNames(filepath, configname) {
  var old_dirname = filepath;
  var dirname = old_dirname;
  var paths = [];
  do {
    paths.push(path.join(dirname, configname || ".editorconfig"));
    old_dirname = dirname;
    dirname = path.dirname(old_dirname);
  } while(dirname != old_dirname);
  return paths;
}

function processMatches(matches, version) {

  // Set indent_size to "tab" if indent_size is unspecified and
  // indent_style is set to "tab".
  if ("indent_style" in matches && matches.indent_style === "tab" &&
    !("indent_size" in matches) && version.gte(new Version(0, 10))) {
    matches.indent_size = "tab";
  }

  // Set tab_width to indent_size if indent_size is specified and
  // tab_width is unspecified
  if ("indent_size" in matches && !("tab_width" in matches) &&
  matches.indent_size !== "tab")
    matches.tab_width = matches.indent_size;

  // Set indent_size to tab_width if indent_size is "tab"
  if("indent_size" in matches && "tab_width" in matches &&
  matches.indent_size === "tab")
    matches.indent_size = matches.tab_width;

  return matches;
}


function processOptions(options) {
  options = options || {};
  options.version = new Version(options.version || pkg.version);
  return options;
}


function parseFromFiles(filepath, configs, options) {
  var matches = {};

  configs.reverse().forEach(function (file) {
    var pathPrefix = path.dirname(file.name);
    var config = file.contents;
    config.forEach(function (section) {
      var fullGlob;
      var glob = section[0];
      var options = section[1];
      if (!glob) return;
      if (glob.indexOf('/') === -1) {
        fullGlob = path.join(pathPrefix, "**/" + glob);
      } else if (glob.indexOf('/') === 0) {
        fullGlob = path.join(pathPrefix, glob.substring(1));
      } else {
        fullGlob = path.join(pathPrefix, glob);
      }
      if (fnmatch(filepath, fullGlob)) {
        for (var key in options) {
          var value = options[key];
          if (knownProps.indexOf(key) !== -1) {
            value = value.toLowerCase();
          }
          try {
            value = JSON.parse(value);
          } catch(e){}
          matches[key.toLowerCase()] = value;
        }
      }
    });
  });

  return processMatches(matches, options.version);

}


function getConfigsForFiles(files) {
  var configs = [];
  for (var i = 0; i < files.length; i++) {
    files[i].contents = iniparser.parseString(files[i].contents);
    configs.push(files[i]);
    if (/^true$/i.test(files[i].contents[0][1].root)) break;
  }
  return configs;
}


function readConfigFiles(filepaths) {
  var files = [];
  filepaths.forEach(function (configFilePath) {
    if (fs.existsSync(configFilePath)) {
      files.push({
        name: configFilePath,
        contents: fs.readFileSync(configFilePath, 'utf-8')
      });
    }
  });
  return files;
}


module.exports.parseFromFiles = function(filepath, files, options) {
  filepath = path.resolve(filepath);
  options = processOptions(options);
  return parseFromFiles(filepath, getConfigsForFiles(files), options);
};


module.exports.parse = function(filepath, options) {
  filepath = path.resolve(filepath);
  options = processOptions(options);
  var filepaths = getConfigFileNames(path.dirname(filepath), options.config);
  var files = readConfigFiles(filepaths);
  return parseFromFiles(filepath, getConfigsForFiles(files), options);
};

},{"fs":3,"path":5,"./lib/fnmatch":6,"./package.json":7,"./lib/ini":8,"./lib/version":9}],7:[function(require,module,exports){
(function(){module.exports={
  "name": "editorconfig",
  "version": "0.11.4",
  "description": "EditorConfig File Locator and Interpreter for Node.js",
  "keywords": [
    "editorconfig",
    "core"
  ],
  "main": "editorconfig.js",
  "contributors": [
    {
      "name": "Hong Xu",
      "url": "topbug.net"
    },
    {
      "name": "Jed Hunsaker",
      "email": "jed.hunsaker[at]gmail.com"
    },
    {
      "name": "Trey Hunner",
      "url": "http://treyhunner.com"
    }
  ],
  "directories": {
    "bin": "./bin",
    "lib": "./lib"
  },
  "scripts": {
    "pretest": "cmake .",
    "test": "ctest .",
    "test-verbose": "ctest -VV --output-on-failure .",
    "codepaint": "codepaint xform -e **/**.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/editorconfig/editorconfig-core-js.git"
  },
  "bugs": {
    "url": "https://github.com/editorconfig/editorconfig-core-js/issues"
  },
  "author": {
    "name": "EditorConfig Team"
  },
  "license": {
    "type": "MIT",
    "url": "http://editorconfig.mit-license.org/2012"
  },
  "dependencies": {
    "commander": "~1.1.1",
    "lru-cache": "~2.0.0",
    "sigmund": "~1.0.0"
  },
  "bin": {
    "editorconfig": "bin/editorconfig"
  },
  "readme": "# EditorConfig JavaScript Core\n\n[![Build Status](https://travis-ci.org/editorconfig/editorconfig-core-js.png?branch=master)](https://travis-ci.org/editorconfig/editorconfig-core-js)\n\nThe EditorConfig JavaScript core will provide the same functionality as the\n[EditorConfig C Core][] and [EditorConfig Python Core][].\n\n\n## Installation\n\nYou need [node][] to use this package.\n\nTo install this package (system-wide):\n\n    $ npm install editorconfig\n\nTo install the package system-wide:\n\n    $ npm install -g editorconfig\n\n\n## Usage\n\nUsage as a Node library:\n\n    $ node\n    > var editorconfig = require('./editorconfig');\n    undefined\n    > editorconfig.parse('/home/zoidberg/humans/anatomy.md');\n    { charset: 'utf-8',\n        insert_final_newline: 'true',\n        end_of_line: 'lf',\n        tab_width: '8',\n        trim_trailing_whitespace: 'sometimes' }\n\n\nUsage as a command line tool:\n\n```\n$ ./bin/editorconfig\n\n    Usage: editorconfig [OPTIONS] FILEPATH1 [FILEPATH2 FILEPATH3 ...]\n\n    EditorConfig Node.js Core Version 0.11.4-development\n\n    FILEPATH can be a hyphen (-) if you want path(s) to be read from stdin.\n\n    Options:\n\n        -h, --help     output usage information\n        -V, --version  output the version number\n        -f <path>      Specify conf filename other than \".editorconfig\"\n        -b <version>   Specify version (used by devs to test compatibility)\n```\n\nExample:\n\n    $ ./bin/editorconfig /home/zoidberg/humans/anatomy.md\n    charset=utf-8\n    insert_final_newline=true\n    end_of_line=lf\n    tab_width=8\n    trim_trailing_whitespace=sometimes\n\n\n## Development\n\nTo install dependencies for this package run this in the package directory:\n\n    $ npm install\n\nNext, run:\n\n    $ npm link\n\nThe global editorconfig will now point to the files in your development\nrepository instead of a globally-installed version from npm. You can now use\neditorconfig directly to test your changes.\n\nIf you ever update from the central repository and there are errors, it might\nbe because you are missing some dependencies. If that happens, just run npm\nlink again to get the latest dependencies.\n\nTo test the command line interface:\n\n    $ editorconfig <filepath>\n\n\n# Testing\n\n[CMake][] must be installed to run the tests.\n\nTo run the tests:\n\n    $ npm test\n\nTo run the tests with increased verbosity (for debugging test failures):\n\n    $ npm run-script test-verbose\n\n[EditorConfig C Core]: https://github.com/editorconfig/editorconfig-core\n[EditorConfig Python Core]: https://github.com/editorconfig/editorconfig-core-py\n[node]: http://nodejs.org/\n[cmake]: http://www.cmake.org\n",
  "readmeFilename": "README.md",
  "_id": "editorconfig@0.11.4",
  "_from": "editorconfig@~0.11.2"
}

})()
},{}],8:[function(require,module,exports){
// Based on iniparser by shockie <https://npmjs.org/package/iniparser>

/*
 * get the file handler
 */
var fs = require('fs');

/*
 * define the possible values:
 * section: [section]
 * param: key=value
 * comment: ;this is a comment
 */
var regex = {
	section: /^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$/,
	param: /^\s*([\w\.\-\_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$/,
	comment: /^\s*[#;].*$/
};

/*
 * parses a .ini file
 * @param: {String} file, the location of the .ini file
 * @param: {Function} callback, the function that will be called when parsing is done
 * @return: none
 */
module.exports.parse = function(file, callback){
	if(!callback){
		return;
	}
	fs.readFile(file, 'utf8', function(err, data){
		if(err){
			callback(err);
		}else{
			callback(null, parse(data));
		}
	});
};

module.exports.parseSync = function(file){
	return parse(fs.readFileSync(file, 'utf8'));
};

function parse(data){
	var sectionBody = {};
	var sectionName = null;
	var value = [[sectionName, sectionBody]];
	var lines = data.split(/\r\n|\r|\n/);
	lines.forEach(function(line){
		var match;
		if(regex.comment.test(line)){
			return;
		}else if(regex.param.test(line)){
			match = line.match(regex.param);
			sectionBody[match[1]] = match[2];
		}else if(regex.section.test(line)){
			match = line.match(regex.section);
			sectionName = match[1];
			sectionBody = {};
			value.push([sectionName, sectionBody]);
		}
	});
	return value;
}

module.exports.parseString = parse;

},{"fs":3}],9:[function(require,module,exports){
function Version(version) {
  var args = arguments;
  this.components = typeof version === "string" ?
    version.split(".").map(function(x){return parseInt(x, 10);}) :
    Object.keys(arguments).map(function(k){return args[k];});

  var len = this.components.length;
  this.major = len ? this.components[0] : 0;
  this.minor = len > 1 ? this.components[1] : 0;
  this.build = len > 2 ? this.components[2] : 0;
  this.revision = len > 3 ? this.components[3] : 0;

  if (typeof version !== "string") {
    return;
  }

  var ext = version.split("-");
  if (ext.length === 2) {
    this.configuration = ext[1];
  }
}

Version.prototype = {
  toString: function() {
    var version = this.components.join(".");
    if (typeof this.configuration !== "undefined") {
      version += "-" + this.configuration;
    }
    return version;
  },
  gte: function(other){
    if (this.major < other.major) {
      return false;
    }
    if (this.minor < other.minor) {
      return false;
    }
    if (this.build < other.build) {
      return false;
    }
    if (this.revision < other.revision) {
      return false;
    }
    return true;
  }
};

module.exports = Version;

},{}],6:[function(require,module,exports){
(function(process){// Based on minimatch.js by isaacs <https://npmjs.org/package/minimatch>

;(function (require, exports, module, platform) {

  if (module) module.exports = minimatch
  else exports.minimatch = minimatch

  if (!require) {
    require = function (id) {
      switch (id) {
        case "sigmund": return function sigmund (obj) {
            return JSON.stringify(obj)
          }
        case "path": return { basename: function (f) {
              f = f.split(/[\/\\]/)
              var e = f.pop()
              if (!e) e = f.pop()
              return e
            }}
        case "lru-cache": return function LRUCache () {
            // not quite an LRU, but still space-limited.
            var cache = {}
            var cnt = 0
            this.set = function (k, v) {
              cnt ++
              if (cnt >= 100) cache = {}
              cache[k] = v
            }
            this.get = function (k) { return cache[k] }
          }
      }
    }
  }

  minimatch.Minimatch = Minimatch

  var LRU = require("lru-cache")
    , cache = minimatch.cache = new LRU({max: 100})
    , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
    , sigmund = require("sigmund")

  var path = require("path")
    // any single thing other than /
    // don't need to escape / when using new RegExp()
    , qmark = "[^/]"

    // * => any number of characters
    , star = qmark + "*?"

    // ** when dots are allowed.  Anything goes, except .. and .
    // not (^ or / followed by one or two dots followed by $ or /),
    // followed by anything, any number of times.
    , twoStarDot = "(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?"

    // not a ^ or / followed by a dot,
    // followed by anything, any number of times.
    , twoStarNoDot = "(?:(?!(?:\\\/|^)\\.).)*?"

    // characters that need to be escaped in RegExp.
    , reSpecials = charSet("().*{}+?[]^$\\!")

// "abc" -> { a:true, b:true, c:true }
  function charSet (s) {
    return s.split("").reduce(function (set, c) {
      set[c] = true
      return set
    }, {})
  }

// normalizes slashes.
  var slashSplit = /\/+/

  minimatch.monkeyPatch = monkeyPatch
  function monkeyPatch () {
    var desc = Object.getOwnPropertyDescriptor(String.prototype, "match")
    var orig = desc.value
    desc.value = function (p) {
      if (p instanceof Minimatch) return p.match(this)
      return orig.call(this, p)
    }
    Object.defineProperty(String.prototype, desc)
  }

  minimatch.filter = filter
  function filter (pattern, options) {
    options = options || {}
    return function (p, i, list) {
      return minimatch(p, pattern, options)
    }
  }

  function ext (a, b) {
    a = a || {}
    b = b || {}
    var t = {}
    Object.keys(b).forEach(function (k) {
      t[k] = b[k]
    })
    Object.keys(a).forEach(function (k) {
      t[k] = a[k]
    })
    return t
  }

  minimatch.defaults = function (def) {
    if (!def || !Object.keys(def).length) return minimatch

    var orig = minimatch

    var m = function minimatch (p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options))
    }

    m.Minimatch = function Minimatch (pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options))
    }

    return m
  }

  Minimatch.defaults = function (def) {
    if (!def || !Object.keys(def).length) return Minimatch
    return minimatch.defaults(def).Minimatch
  }


  function minimatch (p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required")
    }

    if (!options) options = {}

        // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false
    }

    // "" only matches ""
    if (pattern.trim() === "") return p === ""

    return new Minimatch(pattern, options).match(p)
  }

  function Minimatch (pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options, cache)
    }

    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required")
    }

    if (!options) options = {}

        // windows: need to use /, not \
        // On other platforms, \ is a valid (albeit bad) filename char.
    if (platform === "win32") {
      pattern = pattern.split("\\").join("/")
    }

    // lru storage.
    // these things aren't particularly big, but walking down the string
    // and turning it into a regexp can get pretty costly.
    var cacheKey = pattern + "\n" + sigmund(options)
    var cached = minimatch.cache.get(cacheKey)
    if (cached) return cached
    minimatch.cache.set(cacheKey, this)

    this.options = options
    this.set = []
    this.pattern = pattern
    this.regexp = null
    this.negate = false
    this.comment = false
    this.empty = false

      // make the set of regexps etc.
    this.make()
  }

  Minimatch.prototype.make = make
  function make () {
    // don't do it more than once.
    if (this._made) return

    var pattern = this.pattern
    var options = this.options

      // empty patterns and comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true
      return
    }
    if (!pattern) {
      this.empty = true
      return
    }

    // step 1: figure out negation, etc.
    this.parseNegate()

      // step 2: expand braces
    var set = this.globSet = this.braceExpand()

    if (options.debug) console.error(this.pattern, set)

        // step 3: now we have a set, so turn each one into a series of path-portion
        // matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
    set = this.globParts = set.map(function (s) {
        return s.split(slashSplit)
      })

    if (options.debug) console.error(this.pattern, set)

        // glob --> regexps
    set = set.map(function (s, si, set) {
      return s.map(this.parse, this)
    }, this)

    if (options.debug) console.error(this.pattern, set)

        // filter out everything that didn't compile properly.
    set = set.filter(function (s) {
      return -1 === s.indexOf(false)
    })

    if (options.debug) console.error(this.pattern, set)

    this.set = set
  }

  Minimatch.prototype.parseNegate = parseNegate
  function parseNegate () {
    var pattern = this.pattern
      , negate = false
      , options = this.options
      , negateOffset = 0

    if (options.nonegate) return

    for ( var i = 0, l = pattern.length
      ; i < l && pattern.charAt(i) === "!"
      ; i ++) {
      negate = !negate
      negateOffset ++
    }

    if (negateOffset) this.pattern = pattern.substr(negateOffset)
    this.negate = negate
  }

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
  minimatch.braceExpand = function (pattern, options) {
    return new Minimatch(pattern, options).braceExpand()
  }

  Minimatch.prototype.braceExpand = braceExpand
  function braceExpand (pattern, options) {
    options = options || this.options
    pattern = typeof pattern === "undefined"
        ? this.pattern : pattern

    if (typeof pattern === "undefined") {
      throw new Error("undefined pattern")
    }

    if (options.nobrace ||
      !pattern.match(/\{.*\}/)) {
      // shortcut. no need to expand.
      return [pattern]
    }

    var escaping = false

      // examples and comments refer to this crazy pattern:
      // a{b,c{d,e},{f,g}h}x{y,z}
      // expected:
      // abxy
      // abxz
      // acdxy
      // acdxz
      // acexy
      // acexz
      // afhxy
      // afhxz
      // aghxy
      // aghxz

      // everything before the first \{ is just a prefix.
      // So, we pluck that off, and work with the rest,
      // and then prepend it to everything we find.
    if (pattern.charAt(0) !== "{") {
      // console.error(pattern)
      var prefix = null
      for (var i = 0, l = pattern.length; i < l; i ++) {
        var c = pattern.charAt(i)
          // console.error(i, c)
        if (c === "\\") {
          escaping = !escaping
        } else if (c === "{" && !escaping) {
          prefix = pattern.substr(0, i)
          break
        }
      }

      // actually no sets, all { were escaped.
      if (prefix === null) {
        // console.error("no sets")
        return [pattern]
      }

      var tail = braceExpand(pattern.substr(i), options)
      return tail.map(function (t) {
        return prefix + t
      })
    }

    // now we have something like:
    // {b,c{d,e},{f,g}h}x{y,z}
    // walk through the set, expanding each part, until
    // the set ends.  then, we'll expand the suffix.
    // If the set only has a single member, then'll put the {} back

    // first, handle numeric sets, since they're easier
    var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/)
    if (numset) {
      // console.error("numset", numset[1], numset[2])
      var suf = braceExpand(pattern.substr(numset[0].length), options)
        , start = +numset[1]
        , end = +numset[2]
        , inc = start > end ? -1 : 1
        , set = []
      for (var i = start; i != (end + inc); i += inc) {
        // append all the suffixes
        for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
          set.push(i + suf[ii])
        }
      }
      return set
    }

    // ok, walk through the set
    // We hope, somewhat optimistically, that there
    // will be a } at the end.
    // If the closing brace isn't found, then the pattern is
    // interpreted as braceExpand("\\" + pattern) so that
    // the leading \{ will be interpreted literally.
    var i = 1 // skip the \{
      , depth = 1
      , set = []
      , member = ""
      , sawEnd = false
      , escaping = false

    function addMember () {
      set.push(member)
      member = ""
    }

    // console.error("Entering for")
    FOR: for (i = 1, l = pattern.length; i < l; i ++) {
        var c = pattern.charAt(i)
          // console.error("", i, c)

        if (escaping) {
          escaping = false
          member += "\\" + c
        } else {
          switch (c) {
            case "\\":
              escaping = true
              continue

            case "{":
              depth ++
              member += "{"
              continue

            case "}":
              depth --
                // if this closes the actual set, then we're done
              if (depth === 0) {
                addMember()
                  // pluck off the close-brace
                i ++
                break FOR
              } else {
                member += c
                continue
              }

            case ",":
              if (depth === 1) {
                addMember()
              } else {
                member += c
              }
              continue

            default:
              member += c
              continue
          } // switch
        } // else
      } // for

    // now we've either finished the set, and the suffix is
    // pattern.substr(i), or we have *not* closed the set,
    // and need to escape the leading brace
    if (depth !== 0) {
      // console.error("didn't close", pattern)
      return braceExpand("\\" + pattern, options)
    }

    // x{y,z} -> ["xy", "xz"]
    // console.error("set", set)
    // console.error("suffix", pattern.substr(i))
    var suf = braceExpand(pattern.substr(i), options)
      // ["b", "c{d,e}","{f,g}h"] ->
      //   [["b"], ["cd", "ce"], ["fh", "gh"]]
    var addBraces = set.length === 1
      // console.error("set pre-expanded", set)
    set = set.map(function (p) {
      return braceExpand(p, options)
    })
      // console.error("set expanded", set)


      // [["b"], ["cd", "ce"], ["fh", "gh"]] ->
      //   ["b", "cd", "ce", "fh", "gh"]
    set = set.reduce(function (l, r) {
      return l.concat(r)
    })

    if (addBraces) {
      set = set.map(function (s) {
        return "{" + s + "}"
      })
    }

    // now attach the suffixes.
    var ret = []
    for (var i = 0, l = set.length; i < l; i ++) {
      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
        ret.push(set[i] + suf[ii])
      }
    }
    return ret
  }

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
  Minimatch.prototype.parse = parse
  var SUBPARSE = {}
  function parse (pattern, isSub) {
    var options = this.options

      // shortcuts
    if (!options.noglobstar && pattern === "**") return GLOBSTAR
    if (pattern === "") return ""

    var re = ""
      , hasMagic = !!options.nocase
      , escaping = false
      // ? => one single character
      , patternListStack = []
      , plType
      , stateChar
      , inClass = false
      , reClassStart = -1
      , classStart = -1
      // . and .. never match anything that doesn't start with .,
      // even when options.dot is set.
      , patternStart = pattern.charAt(0) === "." ? "" // anything
        // not (start or / followed by . or .. followed by / or end)
        : options.dot ? "(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))"
          : "(?!\\.)"

    function clearStateChar () {
      if (stateChar) {
        // we had some state-tracking character
        // that wasn't consumed by this pass.
        switch (stateChar) {
          case "*":
            re += star
            hasMagic = true
            break
          case "?":
            re += qmark
            hasMagic = true
            break
          default:
            re += "\\"+stateChar
            break
        }
        stateChar = false
      }
    }

    for ( var i = 0, len = pattern.length, c
      ; (i < len) && (c = pattern.charAt(i))
      ; i ++ ) {

      if (options.debug) {
        console.error("%s\t%s %s %j", pattern, i, re, c)
      }

      // skip over any that are escaped.
      if (escaping && reSpecials[c]) {
        re += "\\" + c
        escaping = false
        continue
      }

      SWITCH: switch (c) {
          case "/":
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false

          case "\\":
            clearStateChar()
            escaping = true
            continue

          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (options.debug) {
              console.error("%s\t%s %s %j <-- stateChar", pattern, i, re, c)
            }

            // all of those are literals inside a class, except that
            // the glob [!a] means [^a] in regexp
            if (inClass) {
              if (c === "!" && i === classStart + 1) c = "^"
              re += c
              continue
            }

            // if we already have a stateChar, then it means
            // that there was something like ** or +? in there.
            // Handle the stateChar, then proceed with this one.
            clearStateChar()
            stateChar = c
              // if extglob is disabled, then +(asdf|foo) isn't a thing.
              // just clear the statechar *now*, rather than even diving into
              // the patternList stuff.
            if (options.noext) clearStateChar()
            continue

          case "(":
            if (inClass) {
              re += "("
              continue
            }

            if (!stateChar) {
              re += "\\("
              continue
            }

            plType = stateChar
            patternListStack.push({ type: plType
              , start: i - 1
              , reStart: re.length })
              // negation is (?:(?!js)[^/]*)
            re += stateChar === "!" ? "(?:(?!" : "(?:"
            stateChar = false
            continue

          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)"
              continue
            }

            hasMagic = true
            re += ")"
            plType = patternListStack.pop().type
              // negation is (?:(?!js)[^/]*)
              // The others are (?:<pattern>)<type>
            switch (plType) {
              case "!":
                re += "[^/]*?)"
                break
              case "?":
              case "+":
              case "*": re += plType
              case "@": break // the default anyway
            }
            continue

          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|"
              escaping = false
              continue
            }

            re += "|"
            continue

          // these are mostly the same in regexp and glob
          case "[":
            // swallow any state-tracking char before the [
            clearStateChar()

            if (inClass) {
              re += "\\" + c
              continue
            }

            inClass = true
            classStart = i
            reClassStart = re.length
            re += c
            continue

          case "]":
            //  a right bracket shall lose its special
            //  meaning and represent itself in
            //  a bracket expression if it occurs
            //  first in the list.  -- POSIX.2 2.8.3.2
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c
              escaping = false
              continue
            }

            // finish up the class.
            hasMagic = true
            inClass = false
            re += c
            continue

          default:
            // swallow any state char that wasn't consumed
            clearStateChar()

            if (escaping) {
              // no need
              escaping = false
            } else if (reSpecials[c]
              && !(c === "^" && inClass)) {
              re += "\\"
            }

            re += c

        } // switch
    } // for


    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"
    if (inClass) {
      // split where the last [ was, and escape it
      // this is a huge pita.  We now have to re-walk
      // the contents of the would-be class to re-translate
      // any characters that were passed through as-is
      var cs = pattern.substr(classStart + 1)
        , sp = this.parse(cs, SUBPARSE)
      re = re.substr(0, reClassStart) + "\\[" + sp[0]
      hasMagic = hasMagic || sp[1]
    }

    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    var pl
    while (pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + 3)
        // maybe some even number of \, then maybe 1 \, followed by a |
      tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
        if (!$2) {
          // the | isn't already escaped, so escape it.
          $2 = "\\"
        }

        // need to escape all those slashes *again*, without escaping the
        // one that we need for escaping the | character.  As it works out,
        // escaping an even number of slashes can be done by simply repeating
        // it exactly after itself.  That's why this trick works.
        //
        // I am sorry that you have to see this.
        return $1 + $1 + $2 + "|"
      })

        // console.error("tail=%j\n   %s", tail, tail)
      var t = pl.type === "*" ? star
          : pl.type === "?" ? qmark
            : "\\" + pl.type

      hasMagic = true
      re = re.slice(0, pl.reStart)
        + t + "\\("
        + tail
    }

    // handle trailing things that only matter at the very end.
    clearStateChar()
    if (escaping) {
      // trailing \\
      re += "\\\\"
    }

    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    var addPatternStart = false
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(": addPatternStart = true
    }

    // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== "" && hasMagic) re = "(?=.)" + re

    if (addPatternStart) re = patternStart + re

        // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
      return [ re, hasMagic ]
    }

    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.
    if (!hasMagic) {
      return globUnescape(pattern)
    }

    var flags = options.nocase ? "i" : ""
      , regExp = new RegExp("^" + re + "$", flags)

    regExp._glob = pattern
    regExp._src = re

    return regExp
  }

  minimatch.makeRe = function (pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe()
  }

  Minimatch.prototype.makeRe = makeRe
  function makeRe () {
    if (this.regexp || this.regexp === false) return this.regexp

        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
    var set = this.set

    if (!set.length) return this.regexp = false
    var options = this.options

    var twoStar = options.noglobstar ? star
        : options.dot ? twoStarDot
          : twoStarNoDot
      , flags = options.nocase ? "i" : ""

    var re = set.map(function (pattern) {
      return pattern.map(function (p) {
        return (p === GLOBSTAR) ? twoStar
            : (typeof p === "string") ? regExpEscape(p)
              : p._src
      }).join("\\\/")
    }).join("|")

      // must match entire pattern
      // ending in a * or ** will make it less strict.
    re = "^(?:" + re + ")$"

      // can match anything, as long as it's not this.
    if (this.negate) re = "^(?!" + re + ").*$"

    try {
      return this.regexp = new RegExp(re, flags)
    } catch (ex) {
        return this.regexp = false
      }
  }

  minimatch.match = function (list, pattern, options) {
    var mm = new Minimatch(pattern, options)
    list = list.filter(function (f) {
      return mm.match(f)
    })
    if (options.nonull && !list.length) {
      list.push(pattern)
    }
    return list
  }

  Minimatch.prototype.match = match
  function match (f, partial) {
    // console.error("match", f, this.pattern)
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false
    if (this.empty) return f === ""

    if (f === "/" && partial) return true

    var options = this.options

      // windows: need to use /, not \
      // On other platforms, \ is a valid (albeit bad) filename char.
    if (platform === "win32") {
      f = f.split("\\").join("/")
    }

    // treat the test path as a set of pathparts.
    f = f.split(slashSplit)
    if (options.debug) {
      console.error(this.pattern, "split", f)
    }

    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.

    var set = this.set
      // console.error(this.pattern, "set", set)

    for (var i = 0, l = set.length; i < l; i ++) {
      var pattern = set[i]
      var hit = this.matchOne(f, pattern, partial)
      if (hit) {
        if (options.flipNegate) return true
        return !this.negate
      }
    }

    // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false
    return this.negate
  }

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
  Minimatch.prototype.matchOne = function (file, pattern, partial) {
    var options = this.options

    if (options.debug) {
      console.error("matchOne",
      { "this": this
        , file: file
        , pattern: pattern })
    }

    if (options.matchBase && pattern.length === 1) {
      file = path.basename(file.join("/")).split("/")
    }

    if (options.debug) {
      console.error("matchOne", file.length, pattern.length)
    }

    for ( var fi = 0
        , pi = 0
        , fl = file.length
        , pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi ++, pi ++ ) {

      if (options.debug) {
        console.error("matchOne loop")
      }
      var p = pattern[pi]
        , f = file[fi]

      if (options.debug) {
        console.error(pattern, p, f)
      }

      // should be impossible.
      // some invalid regexp stuff in the set.
      if (p === false) return false

      if (p === GLOBSTAR) {
        if (options.debug)
          console.error('GLOBSTAR', [pattern, p, f])

            // "**"
            // a/**/b/**/c would match the following:
            // a/b/x/y/z/c
            // a/x/y/z/b/c
            // a/b/x/b/x/c
            // a/b/c
            // To do this, take the rest of the pattern after
            // the **, and see if it would match the file remainder.
            // If so, return success.
            // If not, the ** "swallows" a segment, and try again.
            // This is recursively awful.
            //
            // a/**/b/**/c matching a/b/x/y/z/c
            // - a matches a
            // - doublestar
            //   - matchOne(b/x/y/z/c, b/**/c)
            //     - b matches b
            //     - doublestar
            //       - matchOne(x/y/z/c, c) -> no
            //       - matchOne(y/z/c, c) -> no
            //       - matchOne(z/c, c) -> no
            //       - matchOne(c, c) yes, hit
        var fr = fi
          , pr = pi + 1
        if (pr === pl) {
          if (options.debug)
            console.error('** at the end')
              // a ** at the end will just swallow the rest.
              // We have found a match.
              // however, it will not swallow /.x, unless
              // options.dot is set.
              // . and .. are *never* matched by **, for explosively
              // exponential reasons.
          for ( ; fi < fl; fi ++) {
            if (file[fi] === "." || file[fi] === ".." ||
            (!options.dot && file[fi].charAt(0) === ".")) return false
          }
          return true
        }

        // ok, let's see if we can swallow whatever we can.
        WHILE: while (fr < fl) {
            var swallowee = file[fr]

            if (options.debug) {
              console.error('\nglobstar while',
                file, fr, pattern, pr, swallowee)
            }

            // XXX remove this slice.  Just pass the start index.
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              if (options.debug)
                console.error('globstar found match!', fr, fl, swallowee)
                  // found a match.
              return true
            } else {
              // can't swallow "." or ".." ever.
              // can only swallow ".foo" when explicitly asked.
              if (swallowee === "." || swallowee === ".." ||
              (!options.dot && swallowee.charAt(0) === ".")) {
                if (options.debug)
                  console.error("dot detected!", file, fr, pattern, pr)
                break WHILE
              }

              // ** swallows a segment, and continue.
              if (options.debug)
                console.error('globstar swallow a segment, and continue')
              fr ++
            }
          }
        // no match was found.
        // However, in partial mode, we can't say this is necessarily over.
        // If there's more *pattern* left, then
        if (partial) {
          // ran out of file
          // console.error("\n>>> no match, partial?", file, fr, pattern, pr)
          if (fr === fl) return true
        }
        return false
      }

      // something other than **
      // non-magic patterns just have to match exactly
      // patterns with magic have been turned into regexps.
      var hit
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase()
        } else {
          hit = f === p
        }
        if (options.debug) {
          console.error("string match", p, f, hit)
        }
      } else {
        hit = f.match(p)
        if (options.debug) {
          console.error("pattern match", p, f, hit)
        }
      }

      if (!hit) return false
    }

    // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*

    // now either we fell off the end of the pattern, or we're done.
    if (fi === fl && pi === pl) {
      // ran out of pattern and filename at the same time.
      // an exact hit!
      return true
    } else if (fi === fl) {
      // ran out of file, but still had pattern left.
      // this is ok if we're doing the match as part of
      // a glob fs traversal.
      return partial
    } else if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we're on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      var emptyFileEnd = (fi === fl - 1) && (file[fi] === "")
      return emptyFileEnd
    }

    // should be unreachable.
    throw new Error("wtf?")
  }


// replace stuff like \* with *
  function globUnescape (s) {
    return s.replace(/\\(.)/g, "$1")
  }


  function regExpEscape (s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
  }

})( typeof require === "function" ? require : null,
  this,
    typeof module === "object" ? module : null,
    typeof process === "object" ? process.platform : "win32"
)

})(require("__browserify_process"))
},{"path":5,"lru-cache":10,"sigmund":11,"__browserify_process":4}],10:[function(require,module,exports){
(function(){;(function () { // closure for web browsers

if (typeof module === 'object' && module.exports) {
  module.exports = LRUCache
} else {
  // just set the global for non-node platforms.
  this.LRUCache = LRUCache
}

function hOP (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function naiveLength () { return 1 }

function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  var max
  if (typeof options === 'number') {
    max = options
    options = { max: max }
  }
  max = options.max

  if (!options) options = {}

  var lengthCalculator = options.length || naiveLength

  if (typeof lengthCalculator !== "function") {
    lengthCalculator = naiveLength
  }
  if (!max || !(typeof max === "number") || max <= 0 ) {
    // a little bit silly.  maybe this should throw?
    max = Infinity
  }

  var maxAge = options.maxAge || null

  var dispose = options.dispose

  var cache = Object.create(null) // hash of items by key
    , lruList = Object.create(null) // list of items in order of use recency
    , mru = 0 // most recently used
    , length = 0 // number of items in the list
    , itemCount = 0


  // resize the cache when the max changes.
  Object.defineProperty(this, "max",
    { set : function (mL) {
        if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
        max = mL
        // if it gets above double max, trim right away.
        // otherwise, do it whenever it's convenient.
        if (length > max) trim()
      }
    , get : function () { return max }
    , enumerable : true
    })

  // resize the cache when the lengthCalculator changes.
  Object.defineProperty(this, "lengthCalculator",
    { set : function (lC) {
        if (typeof lC !== "function") {
          lengthCalculator = naiveLength
          length = itemCount
          for (var key in cache) {
            cache[key].length = 1
          }
        } else {
          lengthCalculator = lC
          length = 0
          for (var key in cache) {
            cache[key].length = lengthCalculator(cache[key].value)
            length += cache[key].length
          }
        }

        if (length > max) trim()
      }
    , get : function () { return lengthCalculator }
    , enumerable : true
    })

  Object.defineProperty(this, "length",
    { get : function () { return length }
    , enumerable : true
    })


  Object.defineProperty(this, "itemCount",
    { get : function () { return itemCount }
    , enumerable : true
    })

  this.reset = function () {
    if (dispose) {
      for (var k in cache) {
        dispose(k, cache[k].value)
      }
    }
    cache = {}
    lruList = {}
    mru = 0
    length = 0
    itemCount = 0
  }

  // Provided for debugging/dev purposes only. No promises whatsoever that
  // this API stays stable.
  this.dump = function () {
    return cache
  }

  this.set = function (key, value) {
    if (hOP(cache, key)) {
      // dispose of the old one before overwriting
      if (dispose) dispose(key, cache[key].value)
      if (maxAge) cache[key].now = Date.now()
      cache[key].value = value
      this.get(key)
      return true
    }

    var len = lengthCalculator(value)
    var age = maxAge ? Date.now() : 0
    var hit = new Entry(key, value, mru++, len, age)

    // oversized objects fall out of cache automatically.
    if (hit.length > max) {
      if (dispose) dispose(key, value)
      return false
    }

    length += hit.length
    lruList[hit.lu] = cache[key] = hit
    itemCount ++

    if (length > max) trim()
    return true
  }

  this.get = function (key) {
    if (!hOP(cache, key)) return
    var hit = cache[key]
    if (maxAge && (Date.now() - hit.now > maxAge)) {
      this.del(key)
      return
    }
    delete lruList[hit.lu]
    hit.lu = mru ++
    lruList[hit.lu] = hit
    return hit.value
  }

  this.del = function (key) {
    if (!hOP(cache, key)) return
    var hit = cache[key]
    if (dispose) dispose(key, hit.value)
    delete cache[key]
    delete lruList[hit.lu]
    length -= hit.length
    itemCount --
  }

  function trim () {
    if (length <= max) return
    for (var k in lruList) {
      if (length <= max) break;
      var hit = lruList[k]
      if (dispose) dispose(hit.key, hit.value)
      length -= hit.length
      delete cache[ hit.key ]
      delete lruList[k]
    }
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, mru, len, age) {
  this.key = key
  this.value = value
  this.lu = mru
  this.length = len
  this.now = age
}

})()

})()
},{}],11:[function(require,module,exports){
module.exports = sigmund
function sigmund (subject, maxSessions) {
    maxSessions = maxSessions || 10;
    var notes = [];
    var analysis = '';
    var RE = RegExp;

    function psychoAnalyze (subject, session) {
        if (session > maxSessions) return;

        if (typeof subject === 'function' ||
            typeof subject === 'undefined') {
            return;
        }

        if (typeof subject !== 'object' || !subject ||
            (subject instanceof RE)) {
            analysis += subject;
            return;
        }

        if (notes.indexOf(subject) !== -1 || session === maxSessions) return;

        notes.push(subject);
        analysis += '{';
        Object.keys(subject).forEach(function (issue, _, __) {
            // pseudo-private values.  skip those.
            if (issue.charAt(0) === '_') return;
            var to = typeof subject[issue];
            if (to === 'function' || to === 'undefined') return;
            analysis += issue;
            psychoAnalyze(subject[issue], session + 1);
        });
    }
    psychoAnalyze(subject, 0);
    return analysis;
}

// vim: set softtabstop=4 shiftwidth=4:

},{}]},{},[1])
;